# Create a submission file using test matrices and our classifier

from common import *
import numpy as np
import pickle
import xgboost
import sys
import pandas as pd
import scipy

from sklearn.feature_selection import SelectKBest, f_regression, SelectFromModel, chi2
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split

# Paths needed in this code
# Let's put boring part here
main_path = os.path.join(root_path, "test")
dll_matrix_path = os.path.join(main_path, dll_matrix_path)
opcode_matrix_path = os.path.join(main_path, opcode_matrix_path)
section_matrix_path = os.path.join(main_path, section_matrix_path)
stdcall_matrix_path = os.path.join(main_path, stdcall_matrix_path)
byte1g_matrix_path = os.path.join(main_path, byte1g_matrix_path)
byte1f_matrix_path = os.path.join(main_path, byte1f_matrix_path)
byte2g_matrix_path = os.path.join(main_path, byte2g_matrix_path)
byte4g_matrix_path = os.path.join(main_path, byte4g_matrix_path)
byte_image_matrix_path = os.path.join(main_path, byte_image_matrix_path)
length_matrix_path = os.path.join(main_path, length_matrix_dir)

# Byte 2gram
# print("Byte 2gram started")
# byte2g_matrix = np.load(byte2g_matrix_path)
# rfc = RandomForestClassifier(n_estimators=1000, random_state=0, n_jobs=-1)
# sfm = SelectFromModel(rfc, threshold=2e-5)
# sfm.fit(byte2g_matrix, train_label)
# byte2g_imp_matrix = sfm.transform(byte2g_matrix)
# print(byte2g_imp_matrix.shape)
# del byte2g_matrix

# Opcode important features
print("Opcode started")
opcode_matrix = np.load(opcode_matrix_path)
opcode_imp_matrix = opcode_matrix
print(opcode_imp_matrix.shape)
del opcode_matrix

# Stdcall matrix with important features extracted
print("Stdcall started")
stdcall_matrix = np.load(stdcall_matrix_path)
# sfm = pickle.load(open(stdcall_sfm_path, "rb"))
stdcall_important_matrix = stdcall_matrix
print(stdcall_important_matrix.shape)
del stdcall_matrix

# DLL features
print("DLL started")
dll_matrix = np.load(dll_matrix_path)
# sfm2 = pickle.load(open(dll_sfm_path, "rb"))
# dll_important_matrix = sfm2.transform(dll_matrix)
dll_important_matrix = dll_matrix
print(dll_important_matrix.shape)
del dll_matrix

# Byte 1gram
print("Byte 1gram started")
byte1g_matrix = np.load(byte1g_matrix_path)
print(byte1g_matrix.shape)

# Byte 1gram entropy
print("Byte 1gram entropy started")
byte1f_matrix = np.load(byte1f_matrix_path)
byte1f_matrix = byte1f_matrix.reshape(byte1f_matrix.shape[0], 1)
print(byte1f_matrix.shape)

# Section length
print("Section length started")
section_matrix = np.load(section_matrix_path)
print(section_matrix.shape)

# File length features
print("File length started")
length_matrix = np.load(length_matrix_path)
print(length_matrix.shape)

# Byte image features
print("Byte image started")
byte_image_matrix = np.load(byte_image_matrix_path)

# Concatenate matrices
print("Matrices concatenated")
final_matrix = np.hstack((byte1g_matrix, byte1f_matrix, section_matrix, length_matrix))
print(final_matrix.shape)
del opcode_imp_matrix, stdcall_important_matrix, section_matrix

gbm = pickle.load(open(os.path.join(root_path, "final_class_gbm"), "rb"))
prob1 = gbm.predict_proba(final_matrix)

clf = pickle.load(open(os.path.join(root_path, "final_class_xgb"), "rb"))
dMatrix = xgboost.DMatrix(final_matrix)
prob2 = clf.predict(dMatrix).reshape(final_matrix.shape[0], 9)

submission = pd.read_csv(sample_submission_path)
submission.ix[:, 1:] = prob2*0.7 + prob1*0.3
submission.ix[:, 0] = [fn.split(os.sep)[-1].split(".")[0] for fn in test_asm]
submission.to_csv(os.path.join(root_path, "final_submission.csv"), index=False)
